{"version":3,"sources":["scenes/universe/index.jsx","components/logo/index.jsx","App.js","serviceWorker.js","index.js"],"names":["IMG_LOC","MAP_IMG_LOC","BUMP_IMG_LOC","THREE","Mars","data","Uint8Array","rasterTexture","needsUpdate","group","useRef","raster","theta","prevSeconds","useRender","y","current","rotation","set","date","Date","getSeconds","loader","_useMemo","useMemo","load","_useMemo2","Object","slicedToArray","mapTexture","bumpTexture","react_default","a","createElement","ref","three","mesh","position","attach","args","map","bumpMap","bumpScale","meshPhongMaterial","opacity","transparent","Stars","z","Math","sin","degToRad","_useMemo3","geo","mat","color","coords","Array","fill","i","random","vertices","_useMemo4","_ref","_ref2","p1","p2","p3","key","geometry","material","Universe","dist","className","intensity","Logo","App","_useState","useState","_useState2","showRegions","showDrones","universe","Fragment","components_logo","src_scenes_universe","Boolean","window","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3d8e4276.chunk.js","sourcesContent":["import * as THREE from 'three/src/Three';\nimport React, { useState, useEffect, useRef, useMemo } from 'react';\n// A THREE.js React renderer, see: https://github.com/drcmda/react-three-fiber\nimport { Canvas, useRender } from 'react-three-fiber';\n// A React animation lib, see: https://github.com/react-spring/react-spring\nimport { useSpring, animated } from 'react-spring/three';\nimport './index.css';\n\nasync function fetchDronesState() {\n  // try {\n  //   const data = await fetch('http://13.80.136.159:9001/drone/list/alive');\n  //   const drones = await data.json();\n  //   return drones.filter((drone) => drone.x && drone.y);\n  // } catch {\n  //   console.log('error');\n  //   return null;\n  // }\n  return null;\n}\n// function Octahedron() {\n//   const [active, setActive] = useState(false)\n//   const [hovered, setHover] = useState(false)\n//   const vertices = [[-1, 0, 0], [0, 1, 0], [1, 0, 0], [0, -1, 0], [-1, 0, 0]]\n//   const { color, pos, ...props } = useSpring({\n//     color: active ? 'hotpink' : 'white',\n//     pos: active ? [0, 0, 2] : [0, 0, 0],\n//     'material-opacity': hovered ? 0.6 : 0.25,\n//     scale: active ? [1.5, 1.5, 1.5] : [1, 1, 1],\n//     rotation: active ? [THREE.Math.degToRad(180), 0, THREE.Math.degToRad(45)] : [0, 0, 0],\n//     config: { mass: 10, tension: 1000, friction: 300, precision: 0.00001 }\n//   })\n//   return (\n//     <group>\n//       <animated.line position={pos}>\n//         <geometry attach=\"geometry\" vertices={vertices.map(v => new THREE.Vector3(...v))} />\n//         <animated.lineBasicMaterial attach=\"material\" color={color} />\n//       </animated.line>\n//       <animated.mesh onClick={e => setActive(!active)} onPointerOver={e => setHover(true)} onPointerOut={e => setHover(false)} {...props}>\n//         <octahedronGeometry attach=\"geometry\" />\n//         <meshStandardMaterial attach=\"material\" color=\"grey\" transparent />\n//       </animated.mesh>\n//     </group>\n//   )\n// }\n\n/**\n * Generate the initial data texture of given `size` by adding\n * random colors at each x,y position.\n * @param {*} data \n * @param {*} size \n */\nfunction createData(data, size) {\n  for ( var i = 0; i < size; i ++ ) {\n    var stride = i * 3;\n\n    var r = Math.floor( Math.random() * 255 );\n    var g = Math.floor( Math.random() * 255 );\n    var b = Math.floor( Math.random() * 255 );\n\n    data[ stride ] = r;\n    data[ stride + 1 ] = g;\n    data[ stride + 2 ] = b;\n  }\n}\n\n/**\n * Fetch world state data.\n */\nasync function fetchWorldState() {\n  try {\n    const data = await fetch('http://localhost:9001/world/');\n    console.log(JSON.stringify(await data.json()));\n  } catch {\n    console.log('error');\n    return null;\n  }\n  return null;\n}\n\n/**\n * Update every block in the given data texture.\n * @param {*} textRef \n * @param {*} size \n * @param {*} worldState a width x height x 3 array for the RGB color for each x,y position\n */\nfunction updateDataTexture(textRef, size, worldState) {\n  for ( var i = 0; i < size; i ++ ) {\n    var stride = i * 3;\n\n    var r = Math.floor( Math.random() * 255 );\n    var g = Math.floor( Math.random() * 255 );\n    var b = Math.floor( Math.random() * 255 );\n\n    textRef.current.map.image.data.set([r,g,b], stride);\n  }\n  textRef.current.map.needsUpdate = true;\n}\n\nconst IMG_LOC = 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/4273/';\nconst MAP_IMG_LOC = IMG_LOC + 'mars-map.jpg';\nconst BUMP_IMG_LOC = IMG_LOC + 'mars-bump.jpg';\nconst COLORS = [new THREE.Color('white'), new THREE.Color('blue'), new THREE.Color('brown'), new THREE.Color('red')];\n\nfunction getRasterData() {\n  const color = new THREE.Color();\n  const data = [];\n  for (let i = 0; i < 10000; i++) {\n    data[i] = Math.floor(Math.random() * 4);\n  }\n  return data;\n}\n\nfunction Mars() {\n  // Create RASTER texture\n  const width = 100;\n  const height = 100;\n  const size = width * height;\n  const data = new Uint8Array(3 * size);\n  // used the buffer to create a DataTexture\n  // createData(data, size);\n  var rasterTexture = new THREE.DataTexture(data, width, height, THREE.RGBFormat);\n  rasterTexture.needsUpdate = true;\n\n  let group = useRef();\n  let raster = useRef();\n  let theta = 0;\n\n  // useEffect(() => {\n  //   const interval = setInterval(() => {\n  //     const data = getRasterData();\n  //     // for each block in the texture, we check if the color has changed\n  //     for (let i = 0; i < 4000; i++) {\n  //       const currentRGB = raster.current.map.image.data.slice(i, i+3);\n  //       console.log(currentRGB);\n  //       const newColorIdx = data[i];\n  //       const newRGB = COLORS[newColorIdx];\n        \n  //       var r = Math.floor( Math.random() * 255 );\n  //       var g = Math.floor( Math.random() * 255 );\n  //       var b = Math.floor( Math.random() * 255 );\n    \n  //       raster.current.map.image.data.set([r,g,b], i*3);\n  //     }\n  //     raster.current.map.needsUpdate = true;\n  //   }, 1000);\n  //   return () => clearInterval(interval);\n  // }, [0]);\n\n  let prevSeconds = 0;\n\n  // Continuously update the GL render\n  useRender(() => {\n    // const y = Math.sin(THREE.Math.degToRad((theta += 0.08)));\n    theta += 0.0015;\n    const y = theta;\n    group.current.rotation.set(0, y, 0);\n    // Continuously update the RASTER texture\n    const date = new Date();\n    if (date.getSeconds() !== prevSeconds) {\n      // updateDataTexture(raster, size, []);\n      prevSeconds = date.getSeconds();\n\n      // fetchDronesState().then(data => {\n      //   data.filter((drone) => drone.x && drone.y).forEach((drone, i) => {\n      //     console.log(drone)\n      //   })\n      // })\n    }\n  });\n\n  // Load the MARS texture images\n  const loader = new THREE.TextureLoader();\n  const [mapTexture, bumpTexture] = useMemo(() => {\n    return [loader.load(MAP_IMG_LOC), loader.load(BUMP_IMG_LOC)]\n  }, [MAP_IMG_LOC, BUMP_IMG_LOC]);\n\n  return (\n    <group ref={group}>\n      <animated.mesh position={[0,0,0]}>\n        <sphereGeometry attach=\"geometry\" args={[2, 32, 32]} />\n        <meshPhongMaterial attach=\"material\" map={mapTexture} bumpMap={bumpTexture} bumpScale={8} />\n      </animated.mesh>\n      <animated.mesh position={[0,0,0]}>\n        <sphereGeometry attach=\"geometry\" args={[2, 32, 32]} />\n        <animated.meshPhongMaterial attach=\"material\" ref={raster} map={rasterTexture} opacity={0.2} transparent />\n      </animated.mesh>\n    </group>\n  );\n}\n\nfunction Stars() {\n  let group = useRef()\n  let theta = 0\n  useRender(() => {\n    // Some things maybe shouldn't be declarative, we're in the render-loop here with full access to the instance\n    const z = 5 * Math.sin(THREE.Math.degToRad((theta += 0.005)))\n    // const s = Math.cos(THREE.Math.degToRad(theta * 2))\n    group.current.rotation.set(0, z, 0)\n    // group.current.scale.set(s, s, s)\n  })\n  const [geo, mat, vertices, coords] = useMemo(() => {\n    const geo = new THREE.SphereBufferGeometry(0.4, 10, 10)\n    const mat = new THREE.MeshBasicMaterial({ color: new THREE.Color('lightblue') })\n    const coords = new Array(2000).fill().map(i => [Math.random() * 800 - 400, Math.random() * 800 - 400, Math.random() * 800 - 400])\n    return [geo, mat, vertices, coords]\n  }, [])\n  return (\n    <group ref={group}>\n      {coords.map(([p1, p2, p3], i) => (\n        <mesh key={i} geometry={geo} material={mat} position={[p1, p2, p3]} />\n      ))}\n    </group>\n  )\n}\n\nfunction Universe() {\n  return (\n    <Canvas className=\"Universe\">\n      <ambientLight color=\"white\" />\n      <pointLight color=\"white\" intensity={0.05} position={[10, 10, 10]} />\n      <Mars />\n      <Stars />\n    </Canvas>\n  );\n}\n\nexport default Universe;\n\n\n\n","import React from 'react'\nimport './index.css'\n\nfunction Logo () {\n  return (\n    <div className='Logo'>horizon</div>\n  )\n}\n\nexport default Logo\n","import React, { Component, useState, useRef } from 'react'\nimport Universe from './scenes/universe'\nimport Logo from './components/logo'\nimport Controls from './components/controls'\nimport Stats from './components/stats'\n\nfunction App () {\n  const [showRegions, setShowRegions, showDrones, setShowDrones] = useState(false)\n  let universe = useRef()\n  return (\n    <React.Fragment>\n      <Logo />\n      {/* <Controls showRegions={showRegions} setShowRegions={setShowRegions} showDrones={showDrones} setShowDrones={setShowDrones} /> */}\n      <Universe ref={universe} showRegions={showRegions} showDrones={showDrones} />\n    </React.Fragment>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'normalize.css';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}